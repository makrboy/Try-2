const canvas = document.querySelector('canvas');
const ctx = canvas.getContext('2d');

canvas.width = 1000
canvas.height = 1000

// module aliases
let Engine = Matter.Engine,
    Runner = Matter.Runner,
    Bodies = Matter.Bodies,
    Body = Matter.Body,
    Composite = Matter.Composite,
    Common = Matter.Common,
    Vertices = Matter.Vertices;
    
// create an engine
let engine = Engine.create();

// create runner
let runner = Runner.create()

function addPhysicsObject(x ,y ,scale, block, options) {
  const points = block.shape
  let bounds = {min:{x:x,y:y},max:{x:x,y:y}}
  bounds.min.x = points[0][0] * scale + x
  bounds.min.y = points[0][1] * scale + y
  bounds.max.x = points[0][0] * scale + x
  bounds.max.y = points[0][1] * scale + y


  options = options || {}
  let pointsList = ''
  for (let pointIndex = 0; pointIndex < points.length; pointIndex++) {
    const point = points[pointIndex]
    pointsList = pointsList + point[0] * scale + ' '
    pointsList = pointsList + point[1] * scale + ' '

    bounds.min.x = Math.min(bounds.min.x, point[0] * scale + x)
    bounds.min.y = Math.min(bounds.min.y, point[1] * scale + y)
    bounds.max.x = Math.max(bounds.max.x, point[0] * scale + x)
    bounds.max.y = Math.max(bounds.max.y, point[1] * scale + y)

  }
  const body = Bodies.fromVertices(x, y, Vertices.fromPath(pointsList), options, true)
  let offset = {min:{},max:{}}
  offset.min.x = bounds.min.x - body.bounds.min.x
  offset.min.y = bounds.min.y - body.bounds.min.y
  offset.max.x = bounds.max.x - body.bounds.max.x
  offset.max.y = bounds.max.y - body.bounds.max.y

  const radians = (block.angle * (Math.PI / 180)) || 0

  Matter.Body.setPosition(body, {x: x + offset.min.x - .5 * scale, y: y + offset.min.y - .5 * scale}, false)
  Matter.Body.rotate(body, radians)
  Composite.add(engine.world, [body])
  return ({id: body.id, offset: offset})
}

let blocks = {
  star: {
    coverArt: {
      layers: [
        {
          color: [100,100,0],
          steps: [
            [0,0],
            [.25,.5],
            [0,1],
            [.5,.75],
            [1,1],
            [.75,.5],
            [1,0],
            [.5,.25]
          ]
        },
        {
          color: [0,100,100,0.5],
          steps: [
            [.25,.25],
            [.25,.75],
            [.75,.75],
            [.75,.25]
          ]
        }
      ]
    },
    files: {
      file: "Im a file"
    },
    functions: {
      onRender: function(input) {
      },
      inputs: function(input) {

      }
    },
    physics: {
      shape: [[0,0],[.25,.5],[0,1],[.5,.75],[1,1],[.75,.5],[1,0],[.5,.25]]
    }
  },
  basic: {
    coverArt: {
      layers: [
        {
          color: [100,100,100,0.5],
          steps: [[0,0],[0,1],[1,1],[1,0]],
          outline: {
            color: [255,255,255]
          }
        }
      ]
    },
    files: {
      file: "Im a file"
    },
    functions: {
      onRender: function(input) {
      },
      inputs: function(input, self) {
        if (input) {
          if (input.shape) {self.coverArt.layers[0].steps = input.shape
          self.physics.shape = input.shape}
          if (input.color) {self.coverArt.layers[0].color = input.color}
          if (input.outline) {self.coverArt.layers[0].outline = input.outline}
          if (input.angle) {self.physics.angle = input.angle}
        }
      }
    },
    physics: {
      shape: [[0,0],[0,1],[1,1],[1,0]]
    }
  },
  ball: {
    coverArt: {
      layers: [
        {
          outline: {},
          color: [200,200,200],
          steps: [[0.4,0],[0.6,0],[0.8,0.1],[0.9,0.2],[1,0.4],[1,0.6],[0.9,0.8],[0.8,0.9],[0.6,1],[0.4,1],[0.2,0.9],[0.1,0.8],[0,0.6],[0,0.4],[0.1,0.2],[0.2,0.1]]
        },
        {
          rotationEffect: 0,
          color: [0,0,0],
          steps: [[0.3,0.4],[0.2,0.3],[0.3,0.1],[0.4,0.3],[0.6,0.3],[0.7,0.1],[0.8,0.3],[0.7,0.4],[0.3,0.4],[0.3,0.5],[0.2,0.6],[0.2,0.7],[0.3,0.8],[0.4,0.8],[0.5,0.9],[0.6,0.8],[0.7,0.8],[0.8,0.7],[0.8,0.6],[0.7,0.5],[0.3,0.5]]
        },
        {
          rotationEffect: 8,
          color: [255,0,0,.2],
          steps: [[0,-0.25],[-0.25,-0.5],[0,-0.5],[0,-0.25],[0.5,-0.25],[0.25,-0.5],[0.5,-0.75],[0.75,-0.5],[0.5,-0.25],[1,-0.25],[1,-0.5],[1.25,-0.5],[1,-0.25],[1.25,0],[1.5,-0.25],[1.5,0],[1.25,0],[1.25,0.5],[1.5,0.25],[1.75,0.5],[1.5,0.75],[1.25,0.5],[1.25,1],[1.5,1.25],[1.5,1],[1.25,1],[1,1.25],[1.25,1.5],[1,1.5],[1,1.25],[0.5,1.25],[0.75,1.5],[0.5,1.75],[0.25,1.5],[0.5,1.25],[0,1.25],[-0.25,1.5],[0,1.5],[0,1.25],[-0.25,1],[-0.5,1.25],[-0.5,1],[-0.25,1],[-0.25,0.5],[-0.5,0.75],[-0.75,0.5],[-0.5,0.25],[-0.25,0.5],[-0.25,0],[-0.5,-0.25],[-0.5,0],[-0.25,0],[-0.25,1],[0,1.25],[1,1.25],[1.25,1],[1.25,0],[1,-0.25]]         
        },
        {
          rotationEffect: 4,
          color: [0,255,0,.2],
          steps: [[0,-0.25],[-0.25,-0.5],[0,-0.5],[0,-0.25],[0.5,-0.25],[0.25,-0.5],[0.5,-0.75],[0.75,-0.5],[0.5,-0.25],[1,-0.25],[1,-0.5],[1.25,-0.5],[1,-0.25],[1.25,0],[1.5,-0.25],[1.5,0],[1.25,0],[1.25,0.5],[1.5,0.25],[1.75,0.5],[1.5,0.75],[1.25,0.5],[1.25,1],[1.5,1.25],[1.5,1],[1.25,1],[1,1.25],[1.25,1.5],[1,1.5],[1,1.25],[0.5,1.25],[0.75,1.5],[0.5,1.75],[0.25,1.5],[0.5,1.25],[0,1.25],[-0.25,1.5],[0,1.5],[0,1.25],[-0.25,1],[-0.5,1.25],[-0.5,1],[-0.25,1],[-0.25,0.5],[-0.5,0.75],[-0.75,0.5],[-0.5,0.25],[-0.25,0.5],[-0.25,0],[-0.5,-0.25],[-0.5,0],[-0.25,0],[-0.25,1],[0,1.25],[1,1.25],[1.25,1],[1.25,0],[1,-0.25]]         
        },
        {
          rotationEffect: 2,
          color: [0,0,255,.2],
          steps: [[0,-0.25],[-0.25,-0.5],[0,-0.5],[0,-0.25],[0.5,-0.25],[0.25,-0.5],[0.5,-0.75],[0.75,-0.5],[0.5,-0.25],[1,-0.25],[1,-0.5],[1.25,-0.5],[1,-0.25],[1.25,0],[1.5,-0.25],[1.5,0],[1.25,0],[1.25,0.5],[1.5,0.25],[1.75,0.5],[1.5,0.75],[1.25,0.5],[1.25,1],[1.5,1.25],[1.5,1],[1.25,1],[1,1.25],[1.25,1.5],[1,1.5],[1,1.25],[0.5,1.25],[0.75,1.5],[0.5,1.75],[0.25,1.5],[0.5,1.25],[0,1.25],[-0.25,1.5],[0,1.5],[0,1.25],[-0.25,1],[-0.5,1.25],[-0.5,1],[-0.25,1],[-0.25,0.5],[-0.5,0.75],[-0.75,0.5],[-0.5,0.25],[-0.25,0.5],[-0.25,0],[-0.5,-0.25],[-0.5,0],[-0.25,0],[-0.25,1],[0,1.25],[1,1.25],[1.25,1],[1.25,0],[1,-0.25]]         
        },
      ]
    },
    physics: {
      shape: [[0.4,0],[0.6,0],[0.8,0.1],[0.9,0.2],[1,0.4],[1,0.6],[0.9,0.8],[0.8,0.9],[0.6,1],[0.4,1],[0.2,0.9],[0.1,0.8],[0,0.6],[0,0.4],[0.1,0.2],[0.2,0.1]]

    }
  }
}

let matterLinks = {}

let levels = {
  level1: {
    key: [
      blocks.star,
      blocks.basic,
      blocks.ball
    ],
    size: {
      x: 100,
      y: 100
    },
    layout: [
      {x: 500, y: 100, key: 2, scale: 50},
      {x: 200, y: 0, key: 0, scale: 200},
      {x: 225, y: 350, key: 0, scale: 25 , options: {frictionAir: .1}},
      {x: 250, y: 350, key: 0, scale: 25 , options: {frictionAir: .05}},
      {x: 275, y: 350, key: 0, scale: 25 , options: {frictionAir: .01}},
      {x: 400, y: 600, key: 0, scale: 100, inputs: {}},
      {x: 300, y: 200, key: 1, scale: 100, inputs: {shape:[[0,0],[0,1],[1,1],[1,0]]}},
      {x: 500, y: 200, key: 1, scale: 100, inputs: {shape:[[.5,-.5],[1,.5],[.5,1],[0,.5]], color:[0,255,255,0.5]}, options: {frictionAir: 0}},
      {x: 100, y: 950, key: 1, scale: 100, inputs: {shape:[[0,0],[0,1],[8,1],[8,0]]}, options: {isStatic: true}}
    ],
    setupFunc: function(self) {
      for (let i = 0; i < 10; i++) {
        self.layout[9+i] = 
        {
          x: Math.floor(Math.random()*1000),
          y: Math.floor(Math.random()*900), 
          key: 1,
          scale: 25, 
          options: {isStatic: true}, 
          inputs: {angle: Math.random()*360}
        }
        for (let i = 0; i < 25; i++) {
          self.layout[19+i] = 
          {
            x: Math.floor(Math.random()*1000),
            y: -Math.floor(Math.random()*2000), 
            key: 2,
            scale: 25, 
            options: {isStatic: false},
          }
        }
      }
    },
    files: {
    }
  },
  level2: {
    key: [
      blocks.star,
      blocks.basic
    ],
    layout: [
      {x: 500, y: 300, scale: 75, key: 1},
      {x: 500, y: 500, scale: 75, key: 1},
      {x: 500, y: 400, scale: 100, key: 1},
      {x: 400, y: 400, scale: 100, key: 1, inputs: {shape: [[-1,0],[-1,2],[1,2],[1,0]]}},
      {x: 600, y: 400, scale: 100, key: 1, inputs: {shape: [[0,0],[0,3],[2,3],[2,0]]}},
      {x: 100, y: 900, key: 1, scale: 100, inputs: {shape:[[0,0],[0,1],[8,1],[8,0]]}, options: {isStatic: true}}



    ],
    setupFunc: function(self) {
      for (let blockIndex in self.layout) {
        //self.layout[blockIndex].options = {isStatic: true}
      }
    }
  }
}

function initializeLevel(level) {

  //clear the matterLinks
  matterLinks = {}

  // create the engine for Matter
  engine = Engine.create();

  //create an empty array to store the blocks in
  let data = []

  if (level.setupFunc) {
    level.setupFunc(level)
  }
  
  for (let index = 0; index < level.layout.length; index++) {
    let block = level.key[level.layout[index].key]
    let functions
    if (block.functions) {
      functions = block.functions
    }
    data[index] = JSON.parse(JSON.stringify(block))
    if (functions) {
      data[index].functions = functions
    }
    const point = level.layout[index]
    data[index].position = {x: point.x, y: point.y, scale: point.scale}
  }
  level.data = data
  for (let index = 0; index < level.data.length; index++) {
    let block = level.data[index]

    let options
    if (level.layout[index].options) {
      options = level.layout[index].options
    }
    if (block.functions && block.functions.inputs) {
      block.functions.inputs(level.layout[index].inputs, level.data[index])
    }
    if (!Array.isArray(block) && block !== 0 && block.physics) {
      const temp = addPhysicsObject(block.position.x,block.position.y,block.position.scale,block.physics,options)
      block.link = temp.id
      block.offset = temp.offset
      block.originOffset = temp.originOffset
      matterLinks[block.link] = block
    }
  }
}


function render(inputOptions) {
  
  //calculate render
  function setup(inputOptions) {
    let renderStack = {}
    function add(input) {
      if (!renderStack[input.stage]) {renderStack[input.stage] = []}
      renderStack[input.stage].push(input)
    }

    let options = {
      renderWireframes: false,
      renderCoverArt: true,
      renderBounds: false,
      debugMode: false
    }
    inputOptions = inputOptions || {}
    for (let settingName in options) {
      if (inputOptions.hasOwnProperty(settingName)) {
        options[settingName] = inputOptions[settingName]
      }
    }

    //clear slate
    add({stage:1,mode:"fill",color:[25,25,25],steps:[[0,0],[0,1000],[1000,1000],[1000,0]]})

    //grab all the bodies from Matter
    let matterBodies = Composite.allBodies(engine.world)

    // //render block art 
    if (options.renderCoverArt && !options.debugMode) {
      for (let matterBodyIndex in matterBodies) {
        const matterBody = matterBodies[matterBodyIndex]
        const matterBodyLink = matterBody.id
        for (let matterLinkIndex in matterLinks) {
          if (matterLinkIndex == matterBodyLink) {
            const block = matterLinks[matterBodyLink]
            const offset = block.offset
            const matterPosition = matterBody.position
            const scale = block.position.scale
            const origin = {}
            const art = block.coverArt
            const angle = matterBody.angle
            origin.x = matterPosition.x - offset.min.x + .5 * scale
            origin.y = matterPosition.y - offset.min.y + .5 * scale
            if (art && art.layers && art.layers[0]) {
              for (let layerIndex in art.layers) {

                //thank you chatGPT
                function rotatePoint(x, y, radians, center) {

                  // Translate the point to the origin
                  var translatedX = x - center.x;
                  var translatedY = y - center.y;
                
                  // Rotate the point around the origin
                  var rotatedX = translatedX * Math.cos(radians) - translatedY * Math.sin(radians);
                  var rotatedY = translatedX * Math.sin(radians) + translatedY * Math.cos(radians);
                
                  // Translate the point back to its original position
                  return {
                    x: rotatedX + center.x,
                    y: rotatedY + center.y
                  };
                }

                const layer = art.layers[layerIndex]
                const color = layer.color
                const rotationEffect = typeof(layer.rotationEffect) == "number" ? layer.rotationEffect : 1
                const outline = layer.outline
                let newPath = []
                if (color.length < 4) { color[3] = 1 }
                for (let pointIndex = 0; pointIndex < layer.steps.length + 2; pointIndex++) {
                  const point = layer.steps[pointIndex % layer.steps.length]
                  let x = (point[0] - .5) * scale + origin.x
                  let y = (point[1] - .5) * scale + origin.y
                  const temp = rotatePoint(x,y,angle*rotationEffect,matterPosition)
                  x = temp.x
                  y = temp.y
                  newPath.push([x,y])
                }
                add({mode:"fill",stage:5,color:color,steps:newPath})
                if (outline) {
                  const color = (outline.color) ? outline.color : [0,0,0]
                  if (color.length < 4) { color[3] = 1 }
                  add({mode:"outline",stage:5,color:color,steps:newPath,width:(outline.width || 0.025) * scale})
                }
              }
            }
          }
        } 
      } 
    }

    //render wireframes
    if (options.renderWireframes || options.debugMode) {
      let body, part, i, j, k
      ctx.beginPath()
      // render all bodies
      for (i = 0; i < matterBodies.length; i++) {
          body = matterBodies[i]
          if (!body.render.visible) continue;

          // handle compound parts
          for (k = body.parts.length > 1 ? 1 : 0; k < body.parts.length; k++) {
            part = body.parts[k];
            ctx.moveTo(part.vertices[0].x, part.vertices[0].y)
            for (j = 1; j < part.vertices.length; j++) {
              if (!part.vertices[j - 1].isInternal) {
                ctx.lineTo(part.vertices[j].x, part.vertices[j].y)
              } else {
                ctx.moveTo(part.vertices[j].x, part.vertices[j].y)
              }
              if (part.vertices[j].isInternal) {
                ctx.moveTo(part.vertices[(j + 1) % part.vertices.length].x, part.vertices[(j + 1) % part.vertices.length].y)
              }
            }
          ctx.lineTo(part.vertices[0].x, part.vertices[0].y)
        }
      }
    ctx.lineWidth = 1
    ctx.strokeStyle = `rgb(0, 150, 255)`
    ctx.stroke()
    }

    //render bounding boxes 
    if (options.renderBounds || options.debugMode) {
      ctx.beginPath()
      for (let bodyIndex in matterBodies) {
        const bounds = matterBodies[bodyIndex].bounds
        ctx.moveTo(bounds.min.x,bounds.min.y)
        ctx.lineTo(bounds.min.x,bounds.max.y)
        ctx.lineTo(bounds.max.x,bounds.max.y)
        ctx.lineTo(bounds.max.x,bounds.min.y)
        ctx.lineTo(bounds.min.x,bounds.min.y)
      }
      ctx.lineWidth = 2
      ctx.strokeStyle = `rgb(200,0,0)`
      ctx.stroke()
    }
    return renderStack
  }

  function display(stack) {
    //sort the stack
    let list = Object.keys(stack)
    const len = list.length
    for (let i = 0; i < len; i++) {
      for (let j = 0; j < len - 1 - i; j++) {
        if (list[j] > list[j + 1]) {
          const temp = list[j]
          list[j] = list[j + 1] + 0
          list[j + 1] = temp + 0
        }
      }
    } 
    //render the stack
    for (let key in list) {
      const subStack = stack[list[key]]
      for (let index in subStack) {
        const item = subStack[index]
        let color = item.color
        if (color.length < 4) { color[3] = 1 }
        if (item.mode == "fill") {
          ctx.fillStyle = `rgb(${color[0]},${color[1]},${color[2]},${color[3]})`
        } else if (item.mode == "outline") {
          ctx.strokeStyle = `rgb(${color[0]},${color[1]},${color[2]},${color[3]})`
        }
        ctx.beginPath()
        for (let pointIndex = 0; pointIndex < item.steps.length + 1; pointIndex++) {
          const point = item.steps[pointIndex % item.steps.length]
          let x = point[0]
          let y = point[1]
          const scale = {x:screenX/1000,y:screenY/1000}
          x = x * scale.x + canvasOffsetX
          y = y * scale.y + canvasOffsetY
          ctx.lineTo(x,y)
        }
        if (item.mode == "fill") {
          ctx.fill()
        } else if (item.mode == "outline") {
          ctx.lineWidth = item.width
          ctx.stroke()
        }
      }
    }
  }

  const renderStack = setup(inputOptions) || {}
  display(renderStack)

}

let canvasX, canvasY, canvasOffsetX, canvasOffsetY, screenX, screenY
let warp = true
function resize() {
  canvas.width = canvasX = window.innerWidth
  canvas.height = canvasY = window.innerHeight
  if (warp) {
    screenX = canvasX
    screenY = canvasY
    canvasOffsetX = 0
    canvasOffsetY = 0
  } else {
    screenX = Math.min(canvasY,canvasX)
    screenY = screenX
    canvasOffsetX = (canvasX - screenX) / 2
    canvasOffsetY = (canvasY - screenY) / 2
  }
}
window.onresize = resize
resize()


let lastTime = 0
let updateindex = 0
const lagNumber = 1
const timePerSlide = 300
function update(time) {
  const deltaTime = time - lastTime
  lastTime = time

  if (Math.floor(Math.random()*lagNumber) == 0) {
    for (let index = 0; index < lagNumber; index++) {
      Runner.tick(runner, engine)
    }
  }
  render({debugMode:false})
  requestAnimationFrame(update)

  if (updateindex % timePerSlide == 0) {
    const keys = Object.keys(levels);

    const randomIndex = Math.floor(Math.random() * keys.length);

    const randomKey = keys[randomIndex];

      //initializeLevel(levels[randomKey])
      initializeLevel(levels.level1)
  }
  updateindex++
}
requestAnimationFrame(update)

//todo
//fix canvas location
//move debug lines to renderStack

